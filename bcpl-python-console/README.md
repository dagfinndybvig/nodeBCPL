
![bcplbook_](https://github.com/user-attachments/assets/f41a992b-e09a-4a7d-b0b5-c7209550ceac)

# BCPL Python Console

This is a pure Python port of the BCPL INTCODE interpreter (`icint.c`).
It allows compiling and running BCPL programs in a Python environment.

Ported from the Node.js version at [nodeBCPL](https://github.com/dagfinndybvig/nodeBCPL)

For the original JavaScript/Node.js version, see the `bcpl-js-console` directory.  
More or less compatible with the classic book https://archive.org/details/richards1979bcpl/mode/2up

## ⚠️ Performance Note

**This pure Python implementation is significantly slower than the Node.js version.**

The BCPL compiler (syni+trni+cgi) requires executing millions of INTCODE instructions.
While CPython can execute the interpreter loop, it does so much more slowly than V8 (Node.js).

**Recommendations for better performance:**
- Use **PyPy** instead of CPython: `pypy3 icint.py ...` (typically 10-50x faster)
- For production use, prefer the Node.js version in `bcpl-js-console`
- Simple BCPL programs will still work, just with longer compilation times

## Requirements

- Python 3.6 or later (PyPy 3.6+ recommended for better performance)
- No external dependencies (pure Python implementation)

## Files

- `icint.py`: The main interpreter and assembler (ported from `icint.c` / `icint.js`).
- `syni`: The syntax analyzer (INTCODE).
- `trni`: The translator (INTCODE).
- `cgi`: The code generator (INTCODE).
- `libhdr`: The standard library header.
- `test.b`: A sample BCPL program.
- `fact.b`: Factorial example.
- `queens.b`: N-Queens solver example.
- `cmpltest.b`: Compiler test suite.

## Source Code and Generated Files

### Source Code
The source code for your program is a `.b` file (e.g., `test.b`). You can create your own BCPL files in this directory.
- **Input**: `filename.b` (Your BCPL source code)
- **Library**: `libhdr` (Standard library header, usually included via `GET "LIBHDR"`)

### Generated Files
The compilation process generates the following intermediate and final files in the current directory:

1. **`OCODE`**: Intermediate code generated by the first pass (`syni` + `trni`).
   - *Note*: The compiler writes specifically to a file named `OCODE` in the current working directory.
2. **`INTCODE`**: The final executable bytecode generated by the code generator (`cgi`).
   - *Note*: This is the output of the `cgi` pass, which we capture from stdout or file output.

## Usage

### Automated Compilation and Execution

Use the `compile.sh` script to compile and run a BCPL program:

```bash
./compile.sh test.b
```

### Manual Steps

1. **Prepare the compiler:**
   Concatenate `syni` and `trni` (removing the `Z` from `trni`) to create `synitrni`.
   ```bash
   cat syni > synitrni
   tail -n +4 trni >> synitrni
   ```

2. **Compile BCPL to OCODE:**
   ```bash
   python3 icint.py synitrni -itest.b
   ```
   This produces an `OCODE` file.

3. **Compile OCODE to INTCODE:**
   ```bash
   python3 icint.py cgi -iOCODE > INTCODE
   ```
   This produces an `INTCODE` file.

4. **Run INTCODE:**
   ```bash
   python3 icint.py INTCODE
   ```

## Implementation Details

- The interpreter uses 16-bit signed arithmetic to match the original C implementation.
- `syni` and `trni` are concatenated to share the label namespace (or rather, to avoid clearing labels between passes, although they mostly use globals).
- `trni` writes directly to a file named `OCODE` (ignoring standard output redirection for the code itself).
- Pure Python implementation with no external dependencies.

## Differences from Node.js Version

This Python port is functionally equivalent to the Node.js version (`icint.js`) with the following implementation details:
- Uses a plain Python list for memory instead of `ArrayBuffer`/`Int16Array`
- 16-bit signed values are emulated by masking and sign-extending as needed
- Uses standard Python file I/O instead of Node.js `fs` module
- All 16-bit signed/unsigned arithmetic is carefully emulated

## Contributing

If you have cloned this repository to a peripheral computer and made additions, here's how to push them back to the central repository:

### Important: Build Artifacts

This repository includes a `.gitignore` file that automatically excludes generated files from version control:
- `OCODE`, `INTCODE`, `INTCODE_RAW` (compilation outputs)
- `synitrni` (generated by concatenating `syni` and `trni`)
- `__pycache__/` (Python bytecode cache)

These files are generated during compilation and should never be committed. The `.gitignore` ensures you won't accidentally commit them.

### For Direct Contributors (with write access)

1. **Check the status of your changes:**
   ```bash
   git status
   ```

2. **Add your changes to the staging area:**
   ```bash
   git add .
   # Or add specific files:
   git add path/to/file1 path/to/file2
   ```

3. **Commit your changes with a descriptive message:**
   ```bash
   git commit -m "Description of your changes"
   ```

4. **Push your changes to the central repository:**
   ```bash
   git push origin main
   # Or if you're on a different branch:
   git push origin your-branch-name
   ```

### For External Contributors (without write access)

1. **Fork the repository** on GitHub (click the "Fork" button on the repository page).

2. **Add your fork as a remote** (if not already done):
   ```bash
   git remote add fork https://github.com/YOUR_USERNAME/nodeBCPL.git
   ```

3. **Create a new branch for your changes:**
   ```bash
   git checkout -b my-feature-branch
   ```

4. **Add and commit your changes:**
   ```bash
   git add .
   git commit -m "Description of your changes"
   ```

5. **Push to your fork:**
   ```bash
   git push fork my-feature-branch
   ```

6. **Create a Pull Request** on GitHub:
   - Go to the original repository on GitHub
   - Click "New Pull Request"
   - Select your fork and branch
   - Provide a clear description of your changes
   - Submit the pull request

### Before Pushing

Always ensure your local repository is up to date with the central repository:

```bash
git pull origin main
```

This helps avoid merge conflicts and ensures your changes are based on the latest code.
